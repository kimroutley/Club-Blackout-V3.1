import json
import os
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

ROOT = Path(__file__).resolve().parents[1]
ROLES_JSON = ROOT / "assets" / "data" / "roles.json"

ENGINE_FILES = [
    ROOT / "lib" / "logic" / "game_engine.dart",
    ROOT / "lib" / "logic" / "script_builder.dart",
    ROOT / "lib" / "models" / "player.dart",
]

TEST_ROOT = ROOT / "test"
OUT = ROOT / "ROLE_PER_ROLE_REPORT.md"


@dataclass(frozen=True)
class Match:
    path: Path
    line_no: int
    line: str


def load_roles() -> list[dict]:
    with ROLES_JSON.open("r", encoding="utf-8") as f:
        data = json.load(f)
    if not isinstance(data, dict) or "roles" not in data:
        raise SystemExit("roles.json must be an object with a 'roles' array")
    roles = data["roles"]
    if not isinstance(roles, list):
        raise SystemExit("roles.json 'roles' must be a list")
    return roles


def iter_file_lines(path: Path) -> Iterable[tuple[int, str]]:
    try:
        with path.open("r", encoding="utf-8") as f:
            for i, line in enumerate(f, start=1):
                yield i, line.rstrip("\n")
    except UnicodeDecodeError:
        # Skip binary/odd files
        return


def find_mentions(path: Path, patterns: list[re.Pattern]) -> list[Match]:
    hits: list[Match] = []
    for line_no, line in iter_file_lines(path):
        for pat in patterns:
            if pat.search(line):
                hits.append(Match(path=path, line_no=line_no, line=line.strip()))
                break
    return hits


def rel(p: Path) -> str:
    try:
        return p.relative_to(ROOT).as_posix()
    except Exception:
        return p.as_posix()


def is_repeatable_role(role_id: str) -> bool:
    return role_id in {"dealer", "party_animal"}


def main() -> None:
    roles = load_roles()

    # Exclude non-gameplay placeholders if present
    roles = [r for r in roles if r.get("id") not in {"host", "temp"}]

    engine_texts: dict[Path, list[str]] = {}
    for p in ENGINE_FILES:
        engine_texts[p] = [line for _, line in iter_file_lines(p)]

    test_files = sorted(TEST_ROOT.rglob("*_test.dart"))

    lines: list[str] = []
    lines.append("# Role Per-Role Report")
    lines.append("")
    lines.append("Generated by `tools/generate_role_report.py`.")
    lines.append("")
    lines.append("## What this shows")
    lines.append("- Role config (from `assets/data/roles.json`)")
    lines.append("- Where the role is referenced in engine/script/player state")
    lines.append("- Where the role is referenced in tests")
    lines.append("- Quick flags when a role has no obvious wiring (script + engine references)")
    lines.append("")

    for role in sorted(roles, key=lambda r: str(r.get("name", ""))):
        role_id = str(role.get("id"))
        role_name = str(role.get("name"))
        alliance = role.get("alliance")
        rtype = role.get("type")
        night_priority = role.get("night_priority")
        ability = role.get("ability")
        start_alliance = role.get("start_alliance")
        has_binary_choice = role.get("has_binary_choice_at_start")
        choices = role.get("choices")

        # Patterns that tend to indicate wiring
        patterns = [
            re.compile(rf"\\b{re.escape(role_id)}\\b"),
            re.compile(rf"'\\s*{re.escape(role_id)}\\s*'"),
            re.compile(rf'"\\s*{re.escape(role_id)}\\s*"'),
        ]

        engine_hits: list[Match] = []
        for p in ENGINE_FILES:
            engine_hits.extend(find_mentions(p, patterns))

        test_hits: list[Match] = []
        for p in test_files:
            test_hits.extend(find_mentions(p, patterns))

        # Summaries
        has_script_builder = any(m.path.name == "script_builder.dart" for m in engine_hits)
        has_engine = any(m.path.name == "game_engine.dart" for m in engine_hits)
        has_tests = len(test_hits) > 0

        lines.append(f"## {role_name} (`{role_id}`)")
        lines.append("")
        lines.append("**Config**")
        lines.append(f"- alliance: `{alliance}`")
        lines.append(f"- type: `{rtype}`")
        lines.append(f"- night_priority: `{night_priority}`")
        lines.append(f"- ability: `{ability}`")
        if start_alliance is not None:
            lines.append(f"- start_alliance: `{start_alliance}`")
        if has_binary_choice is not None:
            lines.append(f"- has_binary_choice_at_start: `{has_binary_choice}`")
        if choices:
            lines.append(f"- choices: `{choices}`")
        lines.append(f"- repeatable: `{is_repeatable_role(role_id)}`")
        lines.append("")

        lines.append("**Wiring**")
        lines.append(f"- script_builder.dart mention: `{has_script_builder}`")
        lines.append(f"- game_engine.dart mention: `{has_engine}`")
        lines.append(f"- tests mention: `{has_tests}`")
        lines.append("")

        if not has_script_builder and not has_engine:
            lines.append("**Flag**")
            lines.append("- No obvious engine/script wiring found; role may be passive-only or missing integration.")
            lines.append("")

        def dump_section(title: str, hits: list[Match], max_lines: int = 12) -> None:
            lines.append(f"**{title}**")
            if not hits:
                lines.append("- (none)")
                lines.append("")
                return
            # Group by file
            by_file: dict[Path, list[Match]] = {}
            for h in hits:
                by_file.setdefault(h.path, []).append(h)

            # Print a small curated sample (enough to locate quickly)
            remaining = max_lines
            for p in sorted(by_file.keys(), key=lambda x: rel(x)):
                if remaining <= 0:
                    break
                file_hits = by_file[p]
                lines.append(f"- {rel(p)}")
                for h in file_hits[: min(3, remaining)]:
                    snippet = h.line
                    if len(snippet) > 160:
                        snippet = snippet[:157] + "..."
                    lines.append(f"  - L{h.line_no}: {snippet}")
                    remaining -= 1
                    if remaining <= 0:
                        break
            if sum(len(v) for v in by_file.values()) > max_lines:
                lines.append(f"- â€¦({sum(len(v) for v in by_file.values()) - max_lines} more matches omitted)")
            lines.append("")

        dump_section("Engine / Script Mentions (sample)", engine_hits, max_lines=12)
        dump_section("Test Mentions (sample)", test_hits, max_lines=10)

    OUT.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote {rel(OUT)}")


if __name__ == "__main__":
    main()
